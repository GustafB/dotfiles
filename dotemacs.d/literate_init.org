#+TITLE:Emacs Config

* Load better default settings
This is a straight clone of [[https://github.com/hrs/sensible-defaults.el][HRS]] defaults setup
#+BEGIN_SRC emacs-lisp
  (load-file "~/.emacs.d/sensible-defaults.el")
  (sensible-defaults/use-all-settings)
  (sensible-defaults/use-all-keybindings)
  (sensible-defaults/backup-to-temp-directory)
#+END_SRC
* Configure =use-package=
Add MELPA to package-list
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives
               '("melpa" . "http://melpa.org/packages/") t)
  (add-to-list 'package-archives
               '("org" . "https://orgmode.org/elpa") t)
#+END_SRC
Make sure use-package is installed
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+END_SRC

Compile packages and ensure latest version in available - not required anymore
#+BEGIN_SRC emacs-lisp
  ;; (use-package auto-compile
  ;;   :config (auto-compile-on-load-mode))
  ;; (setq load-prefer-newer t)
#+END_SRC
Use quelpa
#+BEGIN_SRC emacs-lisp
  (use-package quelpa
    :ensure t)

  (use-package quelpa-use-package
    :ensure t)

#+END_SRC
* Tweaking UX
** Utility Functions
Some handy functionality, mostly drawn from other configs ([[https://github.com/hrs/][HRS]], [[https://github.com/NicolasPetton][Nicolas Petton]], [[https://github.com/jwiegley][JWiegley]])
#+BEGIN_SRC emacs-lisp
  (defvar saved-window-configuration nil)
  (defun push-window-configuration ()
    (interactive)
    (push (current-window-configuration) saved-window-configuration))

  (defun generate-scratch-buffer ()
    "Create and switch to a temporary scratch buffer with a random
         name."
    (interactive)
    (switch-to-buffer (make-temp-name "scratch-")))

  (defun add-auto-mode (mode &rest patterns)
    "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
    (dolist (pattern patterns)
      (add-to-list 'auto-mode-alist (cons pattern mode))))

  (defun kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (defun iterm-goto-filedir-or-home ()
    "Go to present working dir and focus iterm"
    (interactive)
    (do-applescript
     (concat
      " tell application \"iTerm2\"\n"
      "   tell the current session of current window\n"
      (format "     write text \"cd %s\" \n"
              ;; string escaping madness for applescript
              (replace-regexp-in-string "\\\\" "\\\\\\\\"
                                        (shell-quote-argument (or default-directory "~"))))
      "   end tell\n"
      " end tell\n"
      " do shell script \"open -a iTerm\"\n"
      ))
    )
  ;; Opens iterm
  (defun iterm-focus ()
    (interactive)
    (do-applescript
     " do shell script \"open -a iTerm\"\n"
     ))


  (defun split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

  (defun package-upgrade-all ()
    "Upgrade all packages automatically without showing *Packages* buffer."
    (interactive)
    (package-refresh-contents)
    (let (upgrades)
      (cl-flet ((get-version (name where)
                             (let ((pkg (cadr (assq name where))))
                               (when pkg
                                 (package-desc-version pkg)))))
        (dolist (package (mapcar #'car package-alist))
          (let ((in-archive (get-version package package-archive-contents)))
            (when (and in-archive
                       (version-list-< (get-version package package-alist)
                                       in-archive))
              (push (cadr (assq package package-archive-contents))
                    upgrades)))))
      (if upgrades
          (when (yes-or-no-p
                 (message "Upgrade %d package%s (%s)? "
                          (length upgrades)
                          (if (= (length upgrades) 1) "" "s")
                          (mapconcat #'package-desc-full-name upgrades ", ")))
            (save-window-excursion
              (dolist (package-desc upgrades)
                (let ((old-package (cadr (assq (package-desc-name package-desc)
                                               package-alist))))
                  (package-install package-desc)
                  (package-delete  old-package)))))
        (message "All packages are up to date"))))
#+END_SRC
** UI/UX things
*** Remove scroll bars
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode -1)
#+END_SRC
*** Evil-Mode
#+BEGIN_SRC emacs-lisp
;;(setq evil-want-abbrev-expand-on-insert-exit nil)
;;(evil-mode 0)
;;(add-to-list'evil-emacs-state-modes 'eshell)
#+END_SRC
*** Inhibit startup message
    #+BEGIN_SRC emacs-lisp
    (setq inhibit-startup-message t)
    #+END_SRC
*** Turnoff scroll-bell sound
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC
*** Conservative scrolling
#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC
*** Highlight current line
#+BEGIN_SRC emacs-lisp
  (when window-system
    (global-hl-line-mode))
;;  (set-face-background 'hl-line "#778184")

#+END_SRC
*** Load icons package
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
   :ensure t)
#+END_SRC
*** Load theme
#+BEGIN_SRC emacs-lisp
      (defun my/load-theme (frame)
        (select-frame frame)
        (load-theme 'zerodark t))
      (if (daemonp)
          (add-hook 'after-make-frame-functions #'my/load-theme)
        (load-theme 'zerodark t))
      ;;        (use-package zerodark-theme
        ;;        :ensure t
          ;;      :config
            ;;    (load-theme 'zerodark 'no-confirm))
      ;;          :hook 'zerodark-setup-modeline-format)
       (use-package zerodark-theme
          :ensure t
          :config
          :hook (my/load-theme)
          :init
          (add-hook 'after-init-hook 'zerodark-setup-modeline-format))

#+END_SRC
*** Load rainbow-mode
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :commands rainbow-mode)
#+END_SRC
*** Fonts and resizing
- Sets default font and font size
- Text scaling now affects all buffers, not only current
#+BEGIN_SRC emacs-lisp
  (setq default-font "Menlo")
  (setq default-font-size 14)
  (setq current-font-size default-font-size)

  (setq font-change-increment 1.1)

  (defun font-code ()
    (concat default-font "-" (number-to-string current-font-size)))

  (defun set-font-size ()
    "Set the font to `default-font' at `current-font-size'.
  Set that for the current frame, and also make it the default for
  other, future frames."
    (let ((font-code (font-code)))
      (add-to-list 'default-frame-alist (cons 'font font-code))
      (set-frame-font font-code)))

  (defun reset-font-size ()
    "Change font size back to `default-font-size'."
    (interactive)
    (setq current-font-size default-font-size)
    (set-font-size))

  (defun increase-font-size ()
    "Increase current font size by a factor of `font-change-increment'."
    (interactive)
    (setq current-font-size
          (ceiling (* current-font-size font-change-increment)))
    (set-font-size))

  (defun decrease-font-size ()
    "Decrease current font size by a factor of `font-change-increment', down to a minimum size of 1."
    (interactive)
    (setq current-font-size
          (max 1
               (floor (/ current-font-size font-change-increment))))
    (set-font-size))

  (define-key global-map (kbd "C-)") 'reset-font-size)
  (define-key global-map (kbd "C-+") 'increase-font-size)
  (define-key global-map (kbd "C-=") 'increase-font-size)
  (define-key global-map (kbd "C-_") 'decrease-font-size)
  (define-key global-map (kbd "C--") 'decrease-font-size)

  (reset-font-size)
#+END_SRC
*** Enable function folding
#+BEGIN_SRC emacs-lisp
        (use-package origami
          :ensure t
          :bind (:map origami-mode-map
                      ("C-c C-o" . 'origami-toggle-node)
                      ("C-c C-f" . 'origami-toggle-all-nodes)))
        (add-hook 'global-origami-mode #'origami-mode)
  ;;        :hook global-origami-mode)
#+END_SRC
*** Expand regions
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :commands (er/expand-region er/contract-region)
    :bind (
           ("M-=" . er/expand-region)
           ("M--" . er/contract-region)))

#+END_SRC
*** Flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t)

  (defun adjust-syntax-spellcheck-timer ()
    "Adjust how often we check for errors based on if there are any.
    This lets us fix any errors as quickly as possible, but in a
    clean buffer we're an order of magnitude laxer about checking."
    (setq flycheck-idle-change-delay
          (if flycheck-current-errors 0.5 30.0)))

  ;; Each buffer gets its own idle-change-delay because of the
  ;; buffer-sensitive adjustment above.
  (make-variable-buffer-local 'flycheck-idle-change-delay)

  (add-hook 'flycheck-after-syntax-check-hook
            'adjust-syntax-spellcheck-timer)

  ;; Remove newline checks, since they would trigger an immediate check
  ;; when we want the idle-change-delay to be in effect while editing.
  (setq flycheck-check-syntax-automatically '(save
                                              idle-change
                                              mode-enabled))

  (eval-after-load 'flycheck
    '(custom-set-variables
      '(flycheck-display-errors-function #'flycheck-pos-tip-error-messages)))

  (provide 'setup-flycheck)
  (add-hook 'c-mode-common-hook #'flycheck-mode)
#+END_SRC
*** Load up which-key
Sometimes my brain takes a fart and then its useful to know which key to press
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :defer 5
    :ensure t)
#+END_SRC
* Navigation & Interface
** =ivy=
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t
    :diminish
    :bind (("C-x b" . ivy-switch-buffer)
           ("C-x B" . ivy-switch-buffer-other-window)
           ("M-H"   . ivy-resume))

    :bind (:map ivy-minibuffer-map
                ("<tab>" . ivy-alt-done)
                ("SPC"   . ivy-alt-done-or-space)
                ("C-d"   . ivy-done-or-delete-char)
                ("C-i"   . ivy-partial-or-done)
                ("C-r"   . ivy-previous-line-or-history)
                ("M-r"   . ivy-reverse-i-search))

    :bind (:map ivy-switch-buffer-map
                ("C-k" . ivy-switch-buffer-kill))

    :custom
    (ivy-dynamic-exhibit-delay-ms 200)
    (ivy-height 10)
    (ivy-initial-inputs-alist nil t)
    (ivy-magic-tilde nil)
    (ivy-re-builders-alist '((t . ivy--regex-ignore-order)))
    (ivy-use-virtual-buffers t)
    (ivy-wrap t)

    :preface
    (defun ivy-done-or-delete-char ()
      (interactive)
      (call-interactively
       (if (eolp)
           #'ivy-immediate-done
         #'ivy-delete-char)))

    (defun ivy-alt-done-or-space ()
      (interactive)
      (call-interactively
       (if (= ivy--length 1)
           #'ivy-alt-done
         #'self-insert-command)))

    (defun ivy-switch-buffer-kill ()
      (interactive)
      (debug)
      (let ((bn (ivy-state-current ivy-last)))
        (when (get-buffer bn)
          (kill-buffer bn))
        (unless (buffer-live-p (ivy-state-buffer ivy-last))
          (setf (ivy-state-buffer ivy-last)
                (with-ivy-window (current-buffer))))
        (setq ivy--all-candidates (delete bn ivy--all-candidates))
        (ivy--exhibit)))

    ;; This is the value of `magit-completing-read-function', so that we see
    ;; Magit's own sorting choices.
    (defun my-ivy-completing-read (&rest args)
      (let ((ivy-sort-functions-alist '((t . nil))))
        (apply 'ivy-completing-read args)))

    :config
    (ivy-mode 1)
    (ivy-set-occur 'ivy-switch-buffer 'ivy-switch-buffer-occur))

#+END_SRC
** =ace-window=
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :init
    (progn
      (global-set-key [remap other-window] 'ace-window)
      (custom-set-faces
       '(aw-leading-char-face
         ((t (:inherit ace-jump-face-foreground :height 3.0)))))
      ))
#+END_SRC
** =counsel=
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t)
#+END_SRC
** =swiper=
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure try
    :bind (("C-s" . swiper)
     ("C-r" . swiper)
     ("C-c C-r" . ivy-resume)
     ("M-x" . counsel-M-x)
     ("C-x C-f" . counsel-find-file))
    :config
    (progn
      (ivy-mode 1)
      (setq ivy-use-virtual-buffers t)
      (setq ivy-display-style 'fancy)
      (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
      ))

#+END_SRC
** =dired=
Kill files/buffers that are deleted in dired
#+BEGIN_SRC emacs-lisp
(setq dired-clean-up-buffers-too t)
#+END_SRC
Copy directories recursively without confirmation
#+BEGIN_SRC emacs-lisp
(setq dired-recursive-copies 'always)
#+END_SRC
Ask before recursively deleting a directory
#+BEGIN_SRC emacs-lisp
(setq dired-recursive-deletes 'top)
#+END_SRC
Enable dired+
#+BEGIN_SRC emacs-lisp
  (use-package dired+
    :quelpa (dired+ :fetcher github :repo "emacsmirror/dired-plus"))
#+END_SRC
Enable dired-toggle
#+BEGIN_SRC emacs-lisp
  (use-package dired-toggle
    :ensure nil
    :bind ("C-c ~" . dired-toggle)
    :preface
    (defun my-dired-toggle-mode-hook ()
      (interactive)
      (visual-line-mode 1)
      (setq-local visual-line-fringe-indicators '(nil right-curly-arrow))
      (setq-local word-wrap nil))
    :hook (dired-toggle-mode . my-dired-toggle-mode-hook))

#+END_SRC
** =company=
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :init (progn
            (add-hook 'prog-mode-hook 'company-mode))
    :config (progn
              (setq company-idle-delay 0.5)
              (setq company-tooltip-limit 10)
              (setq company-minimum-prefix-length 2)
              (setq company-tooltip-flip-when-above t)))

  (use-package company-dabbrev
    :ensure nil
    :config (progn
              (setq company-dabbrev-ignore-case t)
              (setq company-dabbrev-downcase nil)))
  (add-hook 'after-init-hook 'global-company-mode)
#+END_SRC
** =google-this=
#+BEGIN_SRC emacs-lisp
  (use-package google-this
    :ensure t
    :bind-keymap ("C-c /" . google-this-mode-submap)
    :bind* ("M-SPC" . google-this-search)
    :bind (:map google-this-mode-map
                ("/" . google-this-search)))

#+END_SRC
** =indent-shift=
#+BEGIN_SRC emacs-lisp
  (use-package indent-shift
    :ensure nil
    :bind (("C-c <" . indent-shift-left)
           ("C-c >" . indent-shift-right)))

#+END_SRC
** =drag-stuff=
#+BEGIN_SRC emacs-lisp
  (use-package drag-stuff
   :ensure t)
  (drag-stuff-global-mode 1)
  (drag-stuff-define-keys)
#+END_SRC
** =multiple-cursors=
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t)
  ;; Edit all selected lines
  (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-M-g") 'mc/mark-all-like-this)
  (global-set-key (kbd "C-.") 'mc/skip-to-next-like-this)
  (global-set-key (kbd "C-,") 'mc/skip-to-previous-like-this)
#+END_SRC
** =ido-mode=
#+BEGIN_SRC emacs-lisp
  (use-package ido
    :ensure t)
  (use-package flx-ido
    :ensure t)
  (use-package ido-vertical-mode
    :ensure t)
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (ido-mode 1)
  (flx-ido-mode 1) ; better/faster matching
  (setq ido-create-new-buffer 'always) ; don't confirm to create new buffers
  (ido-vertical-mode 1)
  (setq ido-vertical-define-keys 'C-n-and-C-p-only)
#+END_SRC
** =ibuffer=
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :ensure nil)
  (use-package ibuffer-vc
    :ensure t)

  ;;; IBuffer:
  ;; Use human readable Size column instead of original one
  (define-ibuffer-column size-h
    (:name "Size" :inline t)
    (let ((bs (buffer-size)))
      (cond ((> bs 1e6) (format "%7.1fmB" (/ bs 1e6)))
            ((> bs 1e3) (format "%7.1fkB" (/ bs 1e3)))
            (t          (format "%7d  " bs)))))

  (setf ibuffer-formats
        '((mark modified read-only vc-status-mini " "
                (name 18 18 :left :elide)
                " "
                (size-h 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " "
                (vc-status 16 16 :left)
                " "
                filename-and-process))
        ibuffer-show-empty-filter-groups nil)

  (define-ibuffer-filter name-not
      "Negated buffer name match."
    (:description "buffer name not"
     :reader (read-from-minibuffer "Exclude buffers (regexp): "))
    (not (string-match qualifier (buffer-name buf))))

  (defvar gk-ibuffer-filters
    '(("Emacs"
       (name . "^\\*\\(scratch\\|Messages\\)\\*$"))
      ("VC"
       (name . "^\\*\\(vc\\|log\\)-?"))
      ("Documentation"
       (name . "^\\*\\(Help\\|info\\|Man [0-9]?\\)"))
      ("Special buffers"
       (name-not . "compilation")
       (name . "^\\*.*\\*$"))
      ("EWW Reading"
       (mode . eww-mode)))
    "Fixed filter definitions for ibuffer.")

  (cl-defun gk-ibuffer-generate-filter-groups-by-dir ()
    "Create a set of ibuffer filter groups based on the dirs of buffers."
    (let* ((func (lambda (buf)
                   (when-let ((bufnam (buffer-file-name buf)))
                     (if-let ((linknam (file-symlink-p bufnam)))
                         (file-name-directory (expand-file-name linknam))
                       (file-name-directory (expand-file-name bufnam))))))
           (dirs (ibuffer-remove-duplicates (delq nil (mapcar func (buffer-list))))))
      (mapcar (lambda (dir) (cons (concat "Directory: " dir) `((dir . ,dir)))) dirs)))

  (define-ibuffer-filter dir
      "Toggle current view to buffers with dir QUALIFIER."
    (:description "directory" :reader (read-from-minibuffer "Filter by dir (regexp): "))
    (ibuffer-awhen (buffer-file-name buf)
      (string= qualifier (file-name-directory it))))

  (define-advice ibuffer-update (:before (&rest args) autogroups)
    "Group related buffers together using ‘ibuffer-vc’ and ‘dir’,
  and special ones sepatarely."
    (ignore args)
    (setf ibuffer-filter-groups
          (append
           gk-ibuffer-filters
           (ibuffer-vc-generate-filter-groups-by-vc-root)
           (gk-ibuffer-generate-filter-groups-by-dir))))

  ;; Hide these buffers by default.
  (defvar gk-ibuffer-collapsed-groups (list "Special buffers" "Emacs" "Documentation"
                                            "VC"))

  (define-advice ibuffer (:after (&rest args) gk-hidden-groups)
    "Hide groups in ‘gk-ibuffer-collapsed-groups’."
    (ignore args)
    (save-excursion
      (dolist (group gk-ibuffer-collapsed-groups)
        (ignore-errors
          (ibuffer-jump-to-filter-group group)
          (ibuffer-toggle-filter-group)))))

  (cl-defun gk-ibuffer-hook ()
    (unless (eq ibuffer-sorting-mode 'alphabetic)
      (ibuffer-do-sort-by-filename/process))
    (ibuffer-update nil t))

  (add-hook 'ibuffer-hook 'gk-ibuffer-hook)

  (provide 'gk-ibuffer)


#+END_SRC
* Version Control & Project Management
** =Magit=
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind (("C-x g" . magit-status)
           ("C-x G" . magit-status-with-prefix))
    :bind (:map magit-mode-map
                ("U" . magit-unstage-all)
                ("M-h") ("M-s") ("M-m") ("M-w"))
    :bind (:map magit-file-section-map ("<C-return>"))
    :bind (:map magit-hunk-section-map ("<C-return>"))
    :preface
    (defun magit-monitor (&optional no-display)
      "Start git-monitor in the current directory."
      (interactive)
      (let* ((path (file-truename
                    (directory-file-name
                     (expand-file-name default-directory))))
             (name (format "*git-monitor: %s*"
                           (file-name-nondirectory path))))
        (unless (and (get-buffer name)
                     (with-current-buffer (get-buffer name)
                       (string= path (directory-file-name default-directory))))
          (with-current-buffer (get-buffer-create name)
            (cd path)
            (ignore-errors
              (start-process "*git-monitor*" (current-buffer)
                             "git-monitor" "-d" path))))))

    (defun magit-status-with-prefix ()
      (interactive)
      (let ((current-prefix-arg '(4)))
        (call-interactively 'magit-status)))

    :hook (magit-mode . hl-line-mode)
    :config
    (use-package magit-commit
      :config
      (use-package git-commit))

    (use-package magit-files
      :config
      (global-magit-file-mode))

    (add-hook 'magit-status-mode-hook #'(lambda () (magit-monitor t)))

    (eval-after-load 'magit-remote
      '(progn
         (magit-define-popup-action 'magit-fetch-popup
           ?f 'magit-get-remote #'magit-fetch-from-upstream ?u t)
         (magit-define-popup-action 'magit-pull-popup
           ?F 'magit-get-upstream-branch #'magit-pull-from-upstream ?u t)
         (magit-define-popup-action 'magit-push-popup
           ?P 'magit--push-current-to-upstream-desc
           #'magit-push-current-to-upstream ?u t))))

  (use-package magit-popup
    :defer t)

  (use-package magit-imerge
    ;; jww (2017-12-10): Need to configure.
    :disabled t
    :after magit)

  (use-package magithub
    :disabled t
    :after magit
    :config
    (magithub-feature-autoinject t)

    (require 'auth-source-pass)
    (defvar my-ghub-token-cache nil)

    (advice-add
     'ghub--token :around
     #'(lambda (orig-func host username package &optional nocreate forge)
         (or my-ghub-token-cache
             (setq my-ghub-token-cache
                   (funcall orig-func host username package nocreate forge))))))

  (use-package magithub-completion
    :commands magithub-completion-enable)

#+END_SRC
** =projectile=
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :defer 5
    :diminish
    :bind* ("C-c TAB" . projectile-find-other-file)
    :bind-keymap ("C-c p" . projectile-command-map)
    :config
    (projectile-global-mode))
#+END_SRC
** =helm=
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :defer t
    :bind (:map helm-map
                ("<tab>" . helm-execute-persistent-action)
                ("C-i"   . helm-execute-persistent-action)
                ("C-z"   . helm-select-action)
                ("A-v"   . helm-previous-page))
    :config
    (helm-autoresize-mode 1))
  (global-set-key (kbd "C-x b") 'helm-buffers-list)
#+END_SRC
* =web-mode=
- Enable rainbow mode
- Set indentation to 2 spaces
#+BEGIN_SRC emacs-lisp
    (use-package web-mode
      :ensure t
      :config
      (add-hook 'web-mode-hook
                (lambda ()
                  (rainbow-mode)
                  (setq web-mode-markup-indent-offset 2)))
      (add-auto-mode
       'web-mode
       "\\.blade$"
       "\\.phtml$"
       "\\.erb$"
       "\\.html$"
       "\\.php$"
       "\\.rhtml$"))
#+END_SRC
* =js2-mode=
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode)))
(add-hook 'j2-mode-hook (lambda () (setq js2-basic-offset 2)))
#+END_SRC
* =json-mode=
#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure t)
#+END_SRC
* =js2-refactor=
#+BEGIN_SRC emacs-lisp
(use-package js2-refactor
  :ensure t)
(use-package xref-js2
  :ensure t)
(setq js2-highlight-level 3)
(add-hook 'js2-mode-hook #'js2-refactor-mode)
(js2r-add-keybindings-with-prefix "C-c C-r")
(define-key js2-mode-map (kbd "C-k") #'js2r-kill)
(add-hook 'js2-mode-hook
  (lambda ()
    (linum-mode 1)))

;; js-mode (which js2 is based on) binds "M-." which conflicts with xref, so
;; unbind it.
(define-key js-mode-map (kbd "M-.") nil)

(add-hook 'js2-mode-hook (lambda ()
  (add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t)))
#+END_SRC
* =markdown
-mode=
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode (("\\`README\\.md\\'" . gfm-mode)
           ("\\.md\\'"          . markdown-mode)
           ("\\.markdown\\'"    . markdown-mode))
    :init (setq markdown-command "multimarkdown"))

  (use-package markdown-preview-mode
    :after markdown-mode
    :config
    (setq markdown-preview-stylesheets
          (list (concat "https://github.com/dmarcotte/github-markdown-preview/"
                        "blob/master/data/css/github.css"))))
  (custom-set-variables '(markdown-command "/usr/local/bin/markdown"))

#+END_SRC
* =rest-client=
Load company-enabled restclient
#+BEGIN_SRC emacs-lisp
  (use-package company-restclient
    :ensure t
    :after (company restclient))
#+END_SRC
Load regular rest client
#+BEGIN_SRC emacs-lisp
  (use-package restclient
    :ensure t
    :mode ("\\.rest\\'" . restclient-mode))
#+END_SRC
* CSS and SCSS
Set indentation for =css-mode=
#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :commands css-mode
    :init
    (setq css-indent-offset 2)
    :config
    (use-package rainbow-mode
      :init
      (dolist (hook '(css-mode-hook sass-mode-hook))
	(add-hook hook 'rainbow-mode))))
#+END_SRC
Disable auto-compile for =scss-mode=
#+BEGIN_SRC emacs-lisp
  (use-package scss-mode
    :ensure t
    :config
    (setq scss-compile-at-save nil))
#+END_SRC
* Org Mode and Task Management
** =org-bullets=
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :config
  (add-hook 'org-mode-hook (lambda() (org-bullets-mode 1))))
#+END_SRC
** =pdf-tools=
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :ensure t)
#+END_SRC
** =org-ref=
I like to be able to store notes when I read papers / studies
#+BEGIN_SRC emacs-lisp
  (use-package org-ref
    :ensure t
    :config
    (setq org-ref-notes-directory "~/Dropbox/org/reading"
          org-ref-bibliography-notes "~/Dropbox/org/reading/index.org"
          org-ref-default-bibliography '("~/Dropbox/org/reading/index.bib")
          org-ref-pdf-directory "~/Dropbox/org/reading/lib/")) ;; where documents are stored

#+END_SRC
** =helm-bibtex=
Library for creating and storing references and citations
#+BEGIN_SRC emacs-lisp
  (use-package helm-bibtex
    :ensure t
    :config
    (setq helm-bibtex-bibliography "~/Dropbox/org/reading/index.bib" ;; where your references are stored
        helm-bibtex-library-path "~/Dropbox/org/reading/lib/" ;; where your pdfs etc are stored
        helm-bibtex-notes-path "~/Dropbox/org/reading/index.org" ;; where your notes are stored
        bibtex-completion-bibliography "~/Dropbox/org/reading/index.bib" ;; writing completion
        bibtex-completion-notes-path "~/Dropbox/org/reading/index.org"))
#+END_SRC
** Cosmetics
#+BEGIN_SRC emacs-lisp
(setq org-ellipsis "⤵")
(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
(setq org-src-window-setup 'current-window)
#+END_SRC

* Keybindings
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x 2") 'split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'split-window-right-and-switch)
  (global-set-key (kbd "C-x C-t") 'iterm-goto-filedir-or-home)
  (global-set-key (kbd "C-x k") 'kill-current-buffer)
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC
#+END_SRC
* Other defaults
Always indent with spaces
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC
Follow symlinks
#+BEGIN_SRC emacs-lisp
  (setq vc-follow-symlinks t)
#+END_SRC
Set default tab width
#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 2)
#+END_SRC
I like to keep the current line highlighted
#+BEGIN_SRC emacs-lisp
  (setq global-hl-line-mode +1)
#+END_SRC
Setup paths for emacs shell
#+BEGIN_SRC emacs-lisp
  (add-to-list 'exec-path "/usr/local/bin")
  (use-package exec-path-from-shell
    :ensure t
    :config (when (memq window-system '(mac ns))
              (exec-path-from-shell-initialize)))
#+END_SRC
Testing new shell command
#+BEGIN_SRC emacs-lisp
;; I want an easy command for opening new shells:
(defun new-shell (name)
  "Opens a new shell buffer with the given name in
asterisks (*name*) in the current directory and changes the
prompt to 'name>'."
  (interactive "sName: ")
  (pop-to-buffer (concat "*" name "*"))
  (unless (eq major-mode 'shell-mode)
    (shell (current-buffer))
    (sleep-for 0 200)
    (delete-region (point-min) (point-max))
    (comint-simple-send (get-buffer-process (current-buffer))
                        (concat "export PS1=\"\033[33m" name "\033[0m:\033[35m\\W\033[0m>\""))))
(global-set-key (kbd "C-c s") 'new-shell)

;; Remove case sensitivity for auto-completion
(setq pcomplete-ignore-case t)

;; Load ansi colors
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
(setq ansi-color-names-vector ["white" "orange red" "green" "yellow" "pale blue" "magenta" "cyan" "tan"])
#+END_SRC
* Email
Add mu and mu4e to load path
#+BEGIN_SRC emacs-lisp
  (let ((default-directory "/usr/local/share/emacs/site-lisp/"))
    (normal-top-level-add-subdirs-to-load-path))
#+END_SRC
Enabel mu4e and link to email account
#+BEGIN_SRC emacs-lisp
  (use-package mu4e
    :config
    (setq mu4e-contexts
          `( ,(make-mu4e-context
               :name "Gmail"
               :match-func (lambda (msg) (when msg
                                           (string-prefix-p "/gmail-personal" (mu4e-message-field msg :maildir))))
               :vars '(
                       (mu4e-trash-folder . "/gmail-personal/[Gmail].Trash")
                       (mu4e-refile-folder . "/gmail-personal/[Gmail].Archive")
                       (mu4e-drafts-folder . "/gmail-personal/[Gmail].Utkast")
                       (mu4e-sent-folder . "/gmail-personal/[Gmail].Skickat")
                       ))
             )))
#+END_SRC
Enable desktop alerts
#+BEGIN_SRC emacs-lisp
  (use-package mu4e-alert
    :ensure t
    :after mu4e
    :init
    (setq mu4e-alert-interesting-mail-query
          "flag:unread maildir:/Gmail/INBOX"
          )
    (mu4e-alert-enable-mode-line-display)
    (defun refresh-mu4e-alert-mode-line ()
      (interactive)
      (mu4e~proc-kill)
      (mu4e-alert-enable-mode-line-display)
      )
    (run-with-timer 0 60 'refresh-mu4e-alert-mode-line))
#+END_SRC
Since offline-imap can't send emails by default so enable this groundbreaking feature
#+BEGIN_SRC emacs-lisp
  ;; I have my "default" parameters from Gmail
  (setq mu4e-sent-folder "/Users/gustafbrostedt/Maildir/sent"
	;; mu4e-sent-messages-behavior 'delete ;; Unsure how this should be configured
	mu4e-drafts-folder "/Users/gustafbrostedt/Maildir/drafts"
	user-mail-address "gustaf.brostedt@gmail.com"
	smtpmail-default-smtp-server "smtp.gmail.com"
	smtpmail-smtp-server "smtp.gmail.com"
	smtpmail-smtp-service 587)

  ;; Now I set a list of
  (defvar my-mu4e-account-alist
    '(("Gmail"
       (mu4e-sent-folder "/Gmail/sent")
       (user-mail-address "gustaf.brostedt@gmail.com")
       (smtpmail-smtp-user "gustaf.brostedt")
       (smtpmail-local-domain "gmail.com")
       (smtpmail-default-smtp-server "smtp.gmail.com")
       (smtpmail-smtp-server "smtp.gmail.com")
       (smtpmail-smtp-service 587)
       )
      ;; Include any other accounts here ...
      ))

  (defun my-mu4e-set-account ()
    "Set the account for composing a message.
     This function is taken from:
       https://www.djcbsoftware.nl/code/mu/mu4e/Multiple-accounts.html"
    (let* ((account
	    (if mu4e-compose-parent-message
		(let ((maildir (mu4e-message-field mu4e-compose-parent-message :maildir)))
		  (string-match "/\\(.*?\\)/" maildir)
		  (match-string 1 maildir))
	      (completing-read (format "Compose with account: (%s) "
				       (mapconcat #'(lambda (var) (car var))
						  my-mu4e-account-alist "/"))
			       (mapcar #'(lambda (var) (car var)) my-mu4e-account-alist)
			       nil t nil nil (caar my-mu4e-account-alist))))
	   (account-vars (cdr (assoc account my-mu4e-account-alist))))
      (if account-vars
	  (mapc #'(lambda (var)
		    (set (car var) (cadr var)))
		account-vars)
	(error "No email account found"))))
  (add-hook 'mu4e-compose-pre-hook 'my-mu4e-set-account)
#+END_SRC
* Life Management
Any setup related to managing my agenda and life in general
** Todo list and archive
#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/Dropbox/org/agenda")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  ;;(setq org-inbox-file "~/Dropbox/inbox.org")
  (setq org-index-file (org-file-path "index.org"))
  (setq org-archive-location
        (concat (org-file-path "archive.org") "::* From %s"))

  (setq org-agenda-files (list org-index-file))

  (defun open-index-file ()
    "Open the master org TODO list."
    (interactive)
    (find-file org-index-file)
    (flycheck-mode -1)
    (end-of-buffer))

  (global-set-key (kbd "C-c i") 'open-index-file)

  (defun mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))

  (define-key org-mode-map (kbd "C-c C-x C-s") 'mark-done-and-archive)

  (setq org-log-done 'time)
#+END_SRC
** =org-journal=
#+BEGIN_SRC emacs-lisp
  ;; Set default path
  (setq org-journal-dir (concat "~/Dropbox/org/agenda/journal/" (format-time-string "%Y/%m/")))
  ;; Define naming convention
  (setq org-journal-file-format "%Y-%m-%d.org")
  ;; Carry-over incomplete todos
  (setq org-journal-carryover-items "TODO=\"TODO\"|TODO=\"STARTED\"")

  (use-package org-journal
    :ensure t)
#+END_SRC
** =org-agenda=
Most of the below is taken from [[http://doc.norang.ca/org-mode.html][My Life In Plain Text]] by Bernt Hanson.

Tell the agenda where to search for files
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (quote( "~/Dropbox/org/agenda")))
#+END_SRC
Add some additional todo keywords and edit highlighting
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))

  (setq org-todo-keyword-faces
        (quote (("TODO" :foreground "red" :weight bold)
                ("NEXT" :foreground "blue" :weight bold)
                ("DONE" :foreground "forest green" :weight bold)
                ("WAITING" :foreground "orange" :weight bold)
                ("HOLD" :foreground "magenta" :weight bold)
                ("CANCELLED" :foreground "forest green" :weight bold)
                ("MEETING" :foreground "forest green" :weight bold)
                ("PHONE" :foreground "forest green" :weight bold))))
#+END_SRC
Allow to key toggling between todo states
/hotkey for changing state:/ =C-c C-t KEY=
#+BEGIN_SRC emacs-lisp
  (setq org-use-fast-todo-selection t)
#+END_SRC
Allow cycling through todo states with arrow keys, =S-left= &  =S-right=
#+BEGIN_SRC emacs-lisp
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+END_SRC
The below triggers will update the tags on todos as they change state
They follow the below structure
- Moving a task to =CANCELLED= adds a =CANCELLED= tag
- Moving a task to =WAITING= adds a =WAITING= tag
- Moving a task to =HOLD= adds =WAITING= and =HOLD= tags
- Moving a task to a done state removes =WAITING= and =HOLD= tags
- Moving a task to =TODO= removes =WAITING=, =CANCELLED=, and =HOLD= tags
- Moving a task to =NEXT= removes =WAITING=, =CANCELLED=, and =HOLD= tags
- Moving a task to =DONE= removes =WAITING=, =CANCELLED=, and =HOLD= tags
#+BEGIN_SRC emacs-lisp
  (setq org-todo-state-tags-triggers
        (quote (("CANCELLED" ("CANCELLED" . t))
                ("WAITING" ("WAITING" . t))
                ("HOLD" ("WAITING") ("HOLD" . t))
                (done ("WAITING") ("HOLD"))
                ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))
#+END_SRC
** =org-capture=
#+BEGIN_SRC emacs-lisp
  (use-package org-capture
    :commands org-capture
    :bind ("C-c c" . org-capture)
    :ensure nil
    :config
    (setq org-directory "~/Dropbox/org/agenda")
    (setq org-default-notes-file "~/Dropbox/org/agenda/refile.org")
    (setq org-capture-templates
        (quote (("t" "todo" entry (file "~/Dropbox/org/agenda/refile.org")
                 "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
                ("r" "respond" entry (file "~/Dropbox/org/agenda/refile.org")
                 "* NEXT Respond to %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n" :clock-in t :clock-resume t :immediate-finish t)
                ("n" "note" entry (file "~/Dropbox/org/agenda/refile.org")
                 "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)
                ;; ("j" "Journal" entry (file+datetree "~/git/org/diary.org")
                ;;  "* %?\n%U\n" :clock-in t :clock-resume t)
                ("w" "org-protocol" entry (file "~/Dropbox/org/agenda/refile.org")
                 "* TODO Review %c\n%U\n" :immediate-finish t)
                ("m" "Meeting" entry (file "~/Dropbox/org/agenda/refile.org")
                 "* MEETING with %? :MEETING:\n%U" :clock-in t :clock-resume t)
                ("p" "Phone call" entry (file "~/Dropbox/org/agenda/refile.org")
                 "* PHONE %? :PHONE:\n%U" :clock-in t :clock-resume t)
                ("h" "Habit" entry (file "~/Dropbox/org/agenda/refile.org")
                 "* NEXT %?\n%U\n%a\nSCHEDULED: %(format-time-string \"%<<%Y-%m-%d %a .+1d/3d>>\")\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n")))))
#+END_SRC
